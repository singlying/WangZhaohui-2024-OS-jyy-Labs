# L1：物理内存管理(pmm)

> 实现动态内存管理

## 实验目的和要求

**目的**：

- 深入了解物理内存管理
- 多处理器编程：从入门到放弃
- 实现kalloc/kfree管理内存分配和回收

**要求**：**实现kalloc/kfree**

- 实现多处理器安全的内存分配和回收，满足以下条件
  - 原子性，无重叠，内存对齐，无内存泄露，错误处理
- 性能优化
  - 保证分配的正确性
  - 保证分配在多处理器上的性能和伸缩性(scalabity)
- 实现32-bit和64-bit版本




## 开发环境

- **AbstractMachine**

>在其他实验报告中，已经介绍了所用到的AbstractMachine的所需内容

在本实验中，需要自主实现在多处理器上运行的物理内存管理，完成物理内存的分配和回收，这是操作系统内核中的分时管理很重要的组成部分。

- **QEMU模拟器**

硬件虚拟化平台，模拟硬件环境，能够在不使用真实硬件的情况下测试和调试 Bare-Metal 程序。



## 内存分配的基本原理和策略

本实验中采用了两种内存分配策略：

- **快速路径 (Fast Path)**: 用于小块内存分配（即小于8192字节的内存请求）。
- **慢速路径 (Slow Path)**: 用于大块内存分配（即大于或等于8192字节的内存请求）。

### 快速路径

快速路径用于分配相对较小的内存块。其基本策略是预先为每个CPU分配固定数量和大小的页面，并将页面分割成不同大小的内存块。当需要分配小块内存时，直接从对应大小的页面中分配。具体策略包括：

- **页面分配**: 每个CPU都有9种不同大小的内存块页面，从最小的32字节到最大的8192字节。每个页面的起始部分存储着一个页面头结构`PageHeader`，该结构包含一个指向当前空闲块的指针以及一个指向下一个页面的指针。
- **内存块管理**: 页面中的内存块通过链表形式管理，页面头的`current_block`指针指向第一个可用的内存块。每当分配一个内存块时，更新`current_block`指针为下一个可用块，直到页面中的所有块都被分配完。
- **页面扩展**: 如果某一页面中的内存块全部被分配完，且继续请求相同大小的内存块，则会分配一个新的页面，并将其链接到现有页面链表的末尾。

### **慢速路径**

慢速路径用于处理大块内存的分配，其策略更为复杂。主要特点如下：

- **节点结构管理**: 慢速路径使用`NodeHeader`和`NodeInfo`结构体来管理大块内存。`NodeHeader`表示空闲的大块内存节点，`NodeInfo`则用于管理已分配的内存块。
- **分配策略**: 在分配大块内存时，首先计算出一个适当的对齐大小，然后在空闲节点链表中找到第一个适合的空闲节点。分配时，会将内存块从该节点中分离出来，并更新链表结构。
- **内存合并**: 当释放内存时，如果相邻的内存块也是空闲的，系统会尝试合并它们，以减少内存碎片，优化内存利用率。

### 内存锁

为了保证多线程环境下的内存分配安全，代码中采用了简单的锁机制。快速路径中的页面锁（`lock`）确保在同一时间只有一个线程能够分配或释放内存块。慢速路径则使用全局锁（`non_page_lock`）保护大块内存的分配和释放操作。

### 对齐与内存碎片

该内存分配器中还包含了一些对齐策略，以保证内存块的地址满足特定的对齐要求。这对于高效的内存访问和减少内存碎片具有重要意义。通过将页面和内存块按大小对齐，可以降低内存碎片的发生概率，提升内存分配的性能。



## 内存分配工作流程分析

在该物理内存管理实验中，内存分配工作流程分为两个主要路径：**快速路径**和**慢速路径**。这两种路径针对不同大小的内存请求进行处理，分别适用于小块内存和大块内存的分配。

### 快速路径（小块内存分配）

**快速路径**用于处理大小小于等于`MAX_BLOCK_SIZE`的内存分配请求，工作流程如下：

1. **确定当前CPU和块大小**：
   - 系统首先获取当前CPU的编号，并根据请求的内存大小计算出最小的合适块大小`block_size`，即`MIN_BLOCK_SIZE`左移至不小于请求大小的最小倍数。
2. **查找可用页面**：
   - 从当前CPU的`PageInfo`结构体中，根据计算得到的块大小索引找到对应的`PageHeader`。此时会遍历链接的页面头，找到第一个具有空闲块的页面。如果所有页面都已满，则分配一个新的页面并将其添加到链表中。
3. **分配内存块**：
   - 系统对找到的页面加锁以避免并发冲突。然后，从页面头的`current_block`中取出第一个空闲块，将该块的指针返回给调用者，并将`current_block`指向下一个空闲块。分配完成后，解锁页面。
4. **特殊情况处理**：
   - 如果找到的页面中没有足够的空闲块（即`header->current_block`为`NULL`），则系统会分配一个新页面，将其链接到已有页面链表的末尾，并从新页面分配块。

### 慢速路径（大块内存分配）

**慢速路径**用于处理大小大于`MAX_BLOCK_SIZE`的内存分配请求，工作流程如下：

1. **计算对齐后的分配大小**：
   - 首先，根据请求的内存大小计算最小的合适分配大小`alloc_size`，确保分配的内存块能满足对齐要求。
2. **遍历空闲链表**：
   - 系统遍历管理大块内存的空闲链表，从链表头开始查找第一个能够满足对齐和大小要求的空闲块。如果找到合适的空闲块，则计算出该块内存的起始地址。
3. **分配内存并更新链表**：
   - 计算得到的内存起始地址经过对齐处理，并确保剩余空间足够用于分配请求。如果满足条件，系统会将内存分配给调用者，同时更新链表中剩余空闲块的信息。
   - 如果空闲块正好满足请求大小，将整个块分配出去；如果空闲块较大，系统会将多余部分作为新的空闲块插入链表中。
4. **特殊情况处理**：
   - 若遍历完整个链表未找到合适的空闲块，分配请求将失败并返回`NULL`。

### 内存分配整体逻辑

系统首先尝试通过快速路径分配内存，若请求的大小超过了预定的阈值，则转而通过慢速路径进行处理。

在快速路径中，内存块的分配高度依赖于页面（`Page`）结构，每个页面内的内存块通过链表进行管理，并按需分配和释放。而慢速路径则采用空闲链表（`Free List`）的方式进行大块内存的管理，通过节点合并和链表更新来动态管理内存。

通过这种分配策略，系统能够有效地管理物理内存，既能快速处理小块内存请求，又能合理分配和回收大块内存，为系统提供了较高的灵活性和性能。



## 测试说明

> 很遗憾，由于不是正式选课，蒋炎岩老师关闭了线上测试online judge的通道，只有自己尝试给出了一些测试用例来进行测试.

测试用例的设计目的是验证物理内存管理器在单线程和多线程环境下的内存分配与释放的正确性：

测试的基本流程通过初始化内存管理器，分别在单线程和多线程环境下执行一系列内存分配与释放操作，验证物理内存管理器的正确性和稳定性。单线程测试主要集中在基本功能的验证，而多线程测试则侧重于并发情况下的安全性和正确性验证。

### 单线程测试

单线程测试主要包括三个子测试函数，用于验证基本的内存分配和释放功能：

- **test_single_alloc_and_free()**：
  - 测试分配超过最大允许大小的内存（失败情况）。
  - 测试分配和释放32字节、33字节、4096字节的内存块，并验证其对齐要求。
  - 验证内存块的分配和释放流程是否按预期工作。
- **test_alloc_full_page()**：
  - 测试当页面被填满时，系统是否正确分配新的页面。
  - 为每种块大小（从32字节到4096字节）依次分配一个完整页面的内存块，然后释放并重新分配。
  - 验证页面满时分配新的页面以及释放后的重新分配是否正确。
- **test_alloc_huge_memory_and_free()**：
  - 测试分配超过普通页面大小的内存块（大于8192字节），即进入慢速路径的情况。
  - 验证大块内存的分配、释放以及再分配的正确性。

### 多线程测试

多线程测试通过创建多个线程，模拟并发分配和释放内存的场景，验证在多线程环境下内存管理器的正确性：

- **test_multi_alloc_and_free()**：
  - 创建8个线程，每个线程执行`alloc_task()`，分配和释放32字节的内存块。
  - 验证在多线程环境下小块内存的分配与释放是否安全有效。
- **test_multi_alloc_huge_memory_and_free()**：
  - 创建8个线程，每个线程执行`alloc_huge_task()`，分配和释放8193字节的大块内存。
  - 验证在多线程环境下大块内存的分配与释放是否安全有效。

> 具体测试样例实现位于(PWD)/kernel/test/

经过以上的测试，内存分配能够在一定压力下保证分配的正确性，处理多处理器操作带来的挑战。



## 心路历程

- 首次接触到并发编程，发现其复杂性，遇到了很大的困难。开始慢慢理解课程中所说的那句话：多处理器编程：从入门到放弃。

  但是如果用everything is a state machine的想法，我觉得可以一步步对内存分配进行改进。如果从刚开始不实现`kfree`，即

  ~~~ c 
  static void kfree(void *ptr) {}
  ~~~

  那么我发现`kalloc`的实现就会变得非常简单，事实上只需要维护一个指针就可以了。在此基础上逐渐改进是一个很好的主意。


- 但很快，我发现我根本不能理解整个项目的编译过程，尤其是Makefile的杂乱的语法令我应接不暇。但幸好是有解决的方法：把 make 工具的执行也想象成是状态机，观察状态机的运行过程。

  ~~~
  make -nB | grep -v '^mkdir' | vim -
  ~~~

  使用**make -nB**命令查看所有的代码，再将其使用vim进行打开，当然重定向到文件也是可以的。在文本中使用一些文本处理，比如加入空行，排版缩进等等，便会得到如下的内容：

  ~~~
  x86_64-linux-gnu-gcc
    -std=gnu11 -O2
    -MMD -Wall -Werror -ggdb
    -Iinclude/ -Iframework/ -I$KERNEL/include -I$AM/am/include/ -I$AM/klib/include/
    -D__ISA__=\"x86_64\"
    -D__ISA_X86_64__
    -D__ARCH__=x86_64-qemu
    -D__ARCH_X86_64_QEMU
    -D__PLATFORM__=qemu
    -D__PLATFORM_QEMU
    -DARCH_H=\"arch/x86_64-qemu.h\"
    -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector -Wno-main -m64 -fPIC -mno-sse
    -c -o $BUILD/x86_64-qemu/framework/main.o
    $KERNEL/framework/main.c
  ~~~

  以上是一个编译.c文件的命令，虽然还是不是很懂，但至少可以借助一些工具对整个项目构建构成有一个大致的了解。

- AbstractMachine的调试并不容易，或多或少经历过这样的历程：

  最开始只能一步步在命令行中书写命令，虽然经常出错。

  之后发现可以写一个Makefile，用make test跑完所有的测试

  甚至还查到，可以实现在每次文件改动后自动运行所有的测试(虽然并没有实现)

  总之，作为一个刚刚接触到纯命令行运行的新手，调试是一个非常痛苦的过程。




