# L1:hello,bare-metal!

> 为计算机硬件编程

## 实验目的

- 在 AbstractMachine 上进行计算机硬件编程的过程和实践

- 无操作系统环境下直接与硬件交互的挑战与学习价值

- 了解图片文件结构相关知识

  ​

## AbstractMachine

> Bare-Metal : 在没有操作系统介入的情况下，直接与硬件进行交互的编程方式。

### 概念

`抽象计算机`是裸机上的 C 语言运行环境，提供 5 组 (15 个) 主要 API，可以实现各类系统软件 (如操作系统)：

- (TRM) `putch`/`halt` - 最基础的计算、显示和停机
- (IOE) `ioe_read/ioe_write` - I/O 设备管理
- (CTE) `ienabled`/`iset`/`yield`/`kcontext` - 中断和异常
- (VME) `protect`/`unprotect`/`map`/`ucontext` - 虚存管理
- (MPE) `cpu_count`/`cpu_current`/`atomic_xchg` - 多处理器

从硬件的视角，“操作系统” 就是一段指令序列；而从数学的视角，任何程序都是状态机——因此，我们没有道理不能轻松愉快地用高级语言 (例如 C 语言) 实现操作系统内核。

AbstractMachine 是由课程老师通过 15 个 C API 实现的硬件抽象层 (hardware abstraction layer, HAL)，使我们可以在 C 代码中操纵计算机硬件。

AbstractMachine是一种抽象，解决的问题是 “能否在不理解硬件机制细节的前提下实现操作系统”，在OS的学习过程中，注重操作系统中的对象和API，把硬件提供的机制 (可以看成是 “指令”) 象成一组 C API，更方便理解操作系统的本质。



### 封装库函数

AbstractMachine 提供的 API 只是 “最少” 的、用于访问硬件的 API。AbstractMachine并没有实现C语言中的常用库函数，对于许多常用的应用逻辑，我们需要手动完善Klib，让其成为C标准库的一个 子集。

在原有的系统中，虽然声明了一些常用函数，但是并没有具体实现:

~~~ c
int printf(const char *fmt, ...) {
  panic("Not implemented");
}
~~~

所以在实验前先实现了一些可能用到的C标准库函数：

~~~c
// abstract-machine/klib/src/
// stdio.c
int printf(const char *fmt, ...);
//stdlib.c
void *malloc(size_t size); // 暂时只实现了很简单的内存管理模型
void free(void *ptr);
~~~




## 开发环境

### QEMU模拟器

QEMU 是一个开源的硬件虚拟化平台，支持多种架构。它可以模拟不同的硬件环境，能够在不使用真实硬件的情况下测试和调试 Bare-Metal 程序。

为什么要使用模拟器？

- 使用 QEMU 是因为它提供了一个安全且灵活的环境，允许开发者在不接触真实硬件的情况下进行低级硬件编程和调试。这在开发 Bare-Metal 程序时尤为重要，因为直接操纵硬件存在风险，且现代操作系统（如 Linux）出于安全性和稳定性的考虑，限制了对底层硬件的直接访问。

本实验QEMU模拟器的具体开发流程如下(在Makefile中实现)：

- 使用交叉编译器工具链编译程序
- 启动QEMU并加载程序
- 运行和调试一般需要直接输出到控制台展示



## 图片加载和展示

### 准备工作

- 选择一张 24 位 BMP 格式的图片，确保图片的大小适合在不同的屏幕分辨率下展示。
- 使用 `xxd` 工具将图片转换为 C 语言数组。运行以下命令，将 BMP 图片转换为 C 语言数组并保存为 `image_data.h`：

~~~bash
xxd -i image.bmp > image_data.h
~~~



### 加载图片数据

- `image_bmp[]` 作为图片数据源。
- 提取图片的相关数据，调用IO接口，将图片的每一行依次绘制到屏幕上：

~~~c
for () {
	for () {
        ...;
        ioe_write(AM_GPU_FBDRAW, &event);
	}
}
~~~



## 内存管理

缺失了操作系统对于内存资源的管理，mare-metal需要设计者自主的管理相关资源。本实验中简单实现了malloc和free函数，初步构建了一个内存管理机制，主要功能是动态分配和释放内存块。

### malloc(size_t size) 函数

`malloc` 函数用于分配一块指定大小的内存，并返回指向这块内存的指针，具体实现为：

**对齐内存块大小**: 为了避免内存碎片，函数将 `size` 调整为 `sizeof(size_t)` 的倍数。这一步通过将 `size` 加上 `sizeof(size_t) - 1`，然后使用按位与运算符来确保内存块大小是对齐的。

**查找空闲块**: 在 `free_list`（空闲块链表）中遍历寻找足够大的空闲块。如果找到合适的块，将其标记为已使用，并返回该块的数据区域的指针。

**分配新块**: 如果找不到合适的空闲块，则尝试在堆空间中分配新的内存块。如果堆空间不足以分配新的块，则返回 `NULL`。

**更新空闲链表**: 如果成功分配新块，则更新空闲链表，将新块链接到链表的末尾。

### free(void *ptr)函数

`free` 函数用于释放之前分配的内存块，使其可以被重新分配。

**标记内存块为空闲**: 将指针 `ptr` 转换为指向其前一个内存块头的指针，然后将该内存块的 `is_free` 标志设置为 1，表示该块为空闲状态。



## 可能存在的问题

### 图片绘制的分辨率问题

当前实现只进行了一个简单的图片绘制偏移和缩放操作，实现图片绘制在窗口中央。但是没有对图片的分辨率进行调整，当绘制不同分辨率的图片时，可能会导致一些绘制的错误。

**解决方案**：一个比较简单的方法是使用矩阵网络的投影，将一个 n×mn×m 的矩形网格 “投影” 到一个 n′×m′n′×m′ 的矩形网格上，在新网格上找到旧网格 “最靠近” 的那个位置对应的像素来绘制对应网格。




